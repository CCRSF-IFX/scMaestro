#!/usr/bin/env python

import argparse
import glob
import itertools
import logging as sflog
import os
import re
import sys
import subprocess
sflog.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=sflog.DEBUG)

from lib.utils import get_smk_file, write_configfile, get_config_val

# get the path of the script
bin_path = os.path.dirname(os.path.realpath(__file__))

work_path = os.getcwd()
os.chdir(work_path)
print(work_path)

class ConditionalRequiredAction4multi(argparse.Action):
    # https://docs.python.org/3/library/argparse.html#action
    def __call__(self, parser, namespace, values, option_string=None):
        # Save the input file name to the namespace
        setattr(namespace, self.dest, values)
        
        # Read the content of the input file
        with open(values, 'r') as file:
            content = file.read()
        
        # Check if the file contains 'TCR'
        if 'TCR' in content:
            # If it contains 'TCR', another argument becomes required
            if not namespace.other_arg:
                parser.error("argument --other-arg is required when input file contains 'TCR'")

class UniqueStore(argparse.Action):
    def __call__(self, parser, namespace, values, option_string):
        if getattr(namespace, self.dest, self.default) is not self.default:
            parser.error(option_string + " appears several times.")
        setattr(namespace, self.dest, values)

#!def prep_config(args):
#!    with open('config.py', 'w') as f:
#!        if args.pipeline != 'multirna':
#!            f.write('unaligned=["%s"]\n' % '","'.join([os.path.abspath(i) for i in args.fastqs]))
#!        f.write('analysis="%s"\n' % (work_path)) 
#!        f.write('ref="%s"\n' % str(args.genome)) 
#!        if args.pipeline == 'rna':
#!            if args.expect:
#!                f.write('numcells="%s"\n' % ','.join([str(args.expect)] * len(samples)))
#!            if args.force:
#!                f.write('numcells="%s"\n' % ','.join([str(args.force)] * len(samples)))
#!            if args.exclude_introns:
#!                f.write('include_introns=False\n')
#!        if args.pipeline == 'pipseq':
#!            if args.force:
#!                f.write('numcells="%s"\n' % ','.join([str(args.force)] * len(samples)))
#!        if args.force:
#!            if not (args.pipeline == 'vdj' or args.pipeline == 'multirna'):
#!                f.write('forcecells=True\n')
#!            if args.pipeline == 'atac':
#!                    f.write('numcells=""\n')

def get_smk_file(pipeline, fullanalysis):
    if pipeline == "rna":
        if fullanalysis:
            return "workflow/Snakefile_rna_fullanalysis"
        else:
            return "workflow/Snakefile_rna"
    elif pipeline == "multi":
        return "workflow/Snakefile_multi"
    elif pipeline == "spatial":
        return "workflow/Snakefile_spatial"
    elif pipeline == "vdj":
        return "workflow/Snakefile_vdj"
    elif pipeline == "multiome":
        return "workflow/Snakefile_multiome"
    elif pipeline == "atac":
        return "workflow/Snakefile_atac"
    elif pipeline == "nopipe":
        return "workflow/Snakefile_nopipe"
    elif pipeline == "pipseq":
        return "workflow/Snakefile_pipseq"
    elif pipeline == "multirna":
        return "workflow/Snakefile_multirna"
    else:
        pass

def prep_ref(args):
    with open('reference.py', 'w') as f:
        f.write(f'''
import config
genomename = ""
if config.ref == "{args.genome}":
''')
        f.write(f'    genomename = "{args.genome}"\n')
        if args.pipeline == 'rna' or args.pipeline == 'multi':
            f.write(f'    transcriptome = "{args.reference}"\n')
        if args.pipeline == 'atac':
            f.write(f'    atac_reference = "{args.reference}"\n')
        if args.pipeline == 'multiome':
            f.write(f'    arc_reference = "{args.reference}"\n') 
        if args.pipeline == 'vdj':
            f.write(f'    vdj_reference = "{args.vdj_reference}"\n') 
        if args.pipeline == 'pipseq':
            f.write(f'    pipseq_reference = "{args.reference}"\n')

def main(args):
    #prep_config(args)
    prep_ref(args)

    subprocess.check_output('cat %s/workflow/config/program.py |grep -v "copydir = " | grep -v "active_scripts =" > program.py' % bin_path, shell=True) 
    subprocess.check_output('cp -r %s/workflow/ .' % bin_path, shell=True) 
    subprocess.check_output('cp %s/workflow/config/submit_ext.sh submit.sh' % bin_path, shell=True) 
    smk_file = get_smk_file(args.pipeline, args.fullanalysis)
    smk_file_re = re.sub(r"/", r"\/", smk_file)
    os.system("""sed -i "s/snakemake --jobname/snakemake -s %s --jobname /" %s """ % (smk_file_re, "submit.sh"))
    print('CONFIG FILE:')
    with open('config.py') as f:
        print(f.read())
    submit = input('Submit now? (y/n): ')
    while submit.lower() not in ['y', 'n']:
        submit = input('Please answer yes(y) or no(n): ')
    if submit.lower() == 'y':
        subprocess.check_output('sbatch submit.sh', shell=True)
        print("Submitted snakemake run for %s in %s" % (args.fastq_path, work_path))

if __name__ == '__main__':
    ## description - Text to display before the argument help (default: none)

    parent_parser = argparse.ArgumentParser(add_help=False)  
    parent_parser.add_argument('-f', '--fastqs', metavar='FASTQPATH', nargs = "*",  \
            action = UniqueStore, required=True, 
            help='Path(s) to fastq files, multiple paths can be provided together. eg. "-f path1 path2"')
    parent_parser.add_argument('-r', '--reference', metavar='REFERENCE FOLDER', 
            help='Reference genome folder for alignment', required=True)
    parent_parser.add_argument('-g', '--genome', 
            help='Genome build, e.g. "hg38", "mm10"', required=True)
    parent_parser.add_argument("-n", "--dryrun", action="store_true", help="dry run") 
    parent_parser.add_argument("--rerun", action="store_true",
            help="dry run then prompt for submitting jobs that need to be rerun")
    parent_parser.add_argument("--unlock", action="store_true",
            help="unlock working directory")

    parent_parser_fa = argparse.ArgumentParser(add_help=False) 
    parent_parser_fa.add_argument("--fullanalysis", action="store_true",
        help="Run full analysis pipeline")
    
    parent_parser_cellnum = argparse.ArgumentParser(add_help=False) 
    group_cell_number = parent_parser_cellnum.add_mutually_exclusive_group()
    group_cell_number.add_argument("--force", type=int,
        help="Run Cell Ranger with --force-cell ")
    group_cell_number.add_argument("--expect", type=int,
        help="Run Cell Ranger with --expect-cells")
    parent_parser_cellnum.add_argument("--exclude-introns", action="store_true",
        help="Exclude intronic reads in count. To maximize sensitivity for \
                whole transcriptome 3’/5’ Single Cell Gene Expression and 3’ \
                Cell Multiplexing experiments, introns will be included in \
                the analysis by default for cellranger (>v7.0.0) count and multi. ") 
    
    parent_parser_vdjchain = argparse.ArgumentParser(add_help=False)
    parent_parser_vdjchain.add_argument("--chain", default="auto", choices=['auto', 'TR', 'IG'], 
        help="Force the analysis to be carried out for a particular chain type.")

    parser = argparse.ArgumentParser(description='scMastro: Comprehensive workflow for processing single cell sequencing data')
    subparsers = parser.add_subparsers(help='sub-command help', dest = 'command')
    ## rna pipeline
    parser_rna = subparsers.add_parser("rna", 
        parents = [parent_parser, parent_parser_fa, parent_parser_cellnum], 
        help='Snakemake pipeline for 10x scRNA-seq data')
    ## multi pipeline
    parser_multi = subparsers.add_parser("multi", 
        parents = [parent_parser, parent_parser_vdjchain], 
        help='Snakemake pipeline for 10x CellRanger multi analysis')
    parser_multi.add_argument("--cmo", action="store_true",
        help="CMO information will be used for multi analysis")
    parser_multi.add_argument("--count", action="store_true",
        help="Run cellranger count for projects with HTO libraries \
                with more 10 individuals mixed. ")
    
    parser_vdj = subparsers.add_parser("vdj", 
        parents = [parent_parser, parent_parser_vdjchain], 
        help='Snakemake pipeline for 10x VDJ data')
    
    parser_multiome = subparsers.add_parser("multiome", 
        parents = [parent_parser], 
        help='Snakemake pipeline for 10x Multiome ATAC + GEX data')
    
    parser_spatial = subparsers.add_parser("spatial", 
        parents = [parent_parser], 
        help='Snakemake pipeline for 10x spatial data')
    parser_spatial.add_argument("--images", metavar="images",
        action = "store", type=str, required= True, 
        help="Metadata for image information. [Required if spatial pipeline is used]")
    spatial_methods = ["cytassist_v1", "cytassist_v2", "non_cytassist"]
    parser_spatial.add_argument("--spatial-method", 
        metavar=f"spatial_method {spatial_methods}", 
        type=str, choices = spatial_methods, required= True, 
        help="""Specify the method used for spatial transcriptomics analysis. \
              Options:                                                        \
              - 'cytassist_v1': Employ Cytassist method using probe set v1    \
              - 'cytassist_v2': Employ Cytassist method using probe set v2    \
              - 'non_cytassist': Employ non-Cytassist method capturing  polyA mRNAs""")
    
    args = parser.parse_args()
    dict_cmd = vars(args)
    if dict_cmd['command'] is None:
        parser.print_help()
        sys.exit(0)
    sflog.info("Subcommand is: " + str(dict_cmd['command']))
    sflog.info(args)
    if args.dryrun or args.rerun or args.unlock:
        pipeline, fullanalysis = get_config_val("config.py")
        smk_file = get_smk_file(pipeline, fullanalysis)
        sflog.debug(smk_file)
        smk_output = subprocess.check_output(f'snakemake -s {smk_file} -np', shell=True)
        if args.rerun:
            sflog.info('CONFIG FILE:')
            with open('config.py') as f:
                print(f.read())
            submit = input('Submit now? (y/n): ')
            while submit.lower() not in ['y', 'n']:
                submit = input('Please answer yes(y) or no(n): ')
            if submit.lower() == 'y':
                subprocess.check_output('sbatch submit.sh', shell=True)
                sflog.info("Submitted snakemake rerun in directory")
        if args.unlock:
                subprocess.check_output(f'snakemake -s {smk_file} --unlock', shell=True)
    else:
        work_path = os.getcwd()
        os.chdir(work_path)
        sample = list(set([os.path.basename(file).split('.')[0] for file in list(itertools.chain.from_iterable([glob.glob(i + '/*') for i in args.fastqs]))]))
        samps = []
        for item in sample:
            if len(re.findall(r"(\S*)_S\d+_L0\d{2}_[RI]", item)) > 0:
              samps.append(re.findall(r"(\S*)_S\d+_L0\d{2}_[RI]", item)[0])
            else:
              samps.append(item)
        samples = list(set(s.replace('Sample_', '') for s in set(samps)))
        samples = sorted(samples)
        write_configfile(args, work_path)
        args.pipeline = vars(args)["command"]

        main(args)
